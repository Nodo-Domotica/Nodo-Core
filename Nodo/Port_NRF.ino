//======================================================================================================================// Poort NRF24L01 // // Ondersteuning voor Nordic Semiconductor nRF24L01 Single chip 2.4 Ghz Tranceiver// t.b.v. Nodo-Domotica. P.K.Tonkes 2015// Deze routines zijn zo opgezet dat zij minimale overhead bevatten en dicht tegen de// werking van de chip. Dit omwille van snelheid, eenvoud en besparing geheugen. // Voor toelichting zie Preliminary product specification Rev. 1.2 van Nordic Semiconductor.//// In onderstaande tabel staat weergegeven hoe de aansluiting plaats vindt: //// NRF24L01:          Mega (HW-SPI):    Small (SW-SPI)   // ---------------------------------------------------------------------------------------// CSN                D49               A0// MOSI               D51               A1// MISO               D50               A2// SCK                D52               A3// CE                 Vcc(+5)           Vcc(+5)// GND                GND               GND// IRQ                -                 -//======================================================================================================================#define NRF_CHANNEL                                36                           // Kanaal op de 2.4Ghz band waarmee de Nodo's met elkaar communiceren.#define NRF_ADDRESS          0xB1,0xB2,0xB3,0xB4,0xB5                           // 5-byte NRF adres (1e byte wordt ingevuld met unitnummer)//======================================================================================================================#if NODO_PORT_NRF24L01#if NODO_MEGA  #define NRF_HARDWARE_SPI                       true  #define NRF_CSN_PIN                              49#else  #define NRF_CSN_PIN                              A0  #define NRF_MOSI_PIN                             A1  #define NRF_MISO_PIN                             A2  #define NRF_SCK_PIN                              A3#endif// Memory Map Mnemonics - Hex-address#define CONFIG              0x00#define EN_AA               0x01#define EN_RXADDR           0x02#define SETUP_AW            0x03#define SETUP_RETR          0x04#define RF_CH               0x05#define RF_SETUP            0x06#define STATUS              0x07#define OBSERVE_TX          0x08#define CD                  0x09#define RX_ADDR_P0          0x0A#define RX_ADDR_P1          0x0B#define RX_ADDR_P2          0x0C#define RX_ADDR_P3          0x0D#define TX_ADDR             0x10#define RX_PW_P0            0x11#define RX_PW_P1            0x12#define RX_PW_P2            0x13#define RX_PW_P3            0x14#define FIFO_STATUS         0x17//Bit Mnemonics                #define MASK_RX_DR             6#define MASK_TX_DS             5#define MASK_MAX_RT            4#define EN_CRC                 3#define CRCO                   2#define PWR_UP                 1#define PRIM_RX                0#define ENAA_P5                5#define ENAA_P4                4#define ENAA_P3                3#define ENAA_P2                2#define ENAA_P1                1#define ENAA_P0                0#define ERX_P5                 5#define ERX_P4                 4#define ERX_P3                 3#define ERX_P2                 2#define ERX_P1                 1#define ERX_P0                 0#define AW                     0#define ARD                    4#define ARC                    0#define PLL_LOCK               4#define RF_DR                  3#define RF_PWR                 1#define LNA_HCURR              0        #define RX_DR                  6#define TX_DS                  5#define MAX_RT                 4#define RX_P_NO                1#define TX_FULL                0#define PLOS_CNT               4#define ARC_CNT                0#define CD                     0#define TX_REUSE               6#define FIFO_FULL              5#define TX_EMPTY               4#define RX_FULL                1#define RX_EMPTY               0// NRF24L01 - SPI-Instruction set#define R_REGISTER          0x00#define W_REGISTER          0x20#define R_RX_PAYLOAD        0x61#define W_TX_PAYLOAD        0xA0#define FLUSH_TX            0xE1#define FLUSH_RX            0xE2#define REUSE_TX_PL         0xE3#define NOP                 0xFFvoid NRF24L01_R_REGISTER(uint8_t reg, uint8_t *data, uint8_t len)  {  NRF24L01_CSN(LOW);  SPI_transfer(R_REGISTER | (0x1F & reg));	for(uint8_t i = 0;i < len;i++)		data[i] = SPI_transfer(data[i]);  NRF24L01_CSN(HIGH);  } void NRF24L01_W_REGISTER_1(uint8_t reg, uint8_t value)  {  NRF24L01_CSN(LOW);  SPI_transfer(W_REGISTER | (0x1F & reg));  SPI_transfer(value);  NRF24L01_CSN(HIGH);  }void NRF24L01_W_REGISTER(uint8_t reg, uint8_t *value, uint8_t len)   {  NRF24L01_CSN(LOW);  SPI_transfer(W_REGISTER | (0x1F & reg));	for(uint8_t i = 0;i < len;i++)		SPI_transfer(value[i]);  NRF24L01_CSN(HIGH);  }void NRF24L01_R_RX_PAYLOAD(uint8_t *data, uint8_t len)   {  NRF24L01_CSN(LOW);  SPI_transfer(R_RX_PAYLOAD);	for(uint8_t i = 0;i < len;i++)		data[i] = SPI_transfer(data[i]);  NRF24L01_CSN(HIGH);  NRF24L01_W_REGISTER_1(STATUS,(1<<RX_DR));  }void NRF24L01_W_TX_PAYLOAD(uint8_t *data, uint8_t len)  {  NRF24L01_CSN(LOW);  SPI_transfer(W_TX_PAYLOAD);	for(uint8_t i = 0;i < len;i++)		SPI_transfer(data[i]);  NRF24L01_CSN(HIGH);  }void NRF24L01_FLUSH_TX(void)  {  NRF24L01_CSN(LOW);  SPI_transfer(FLUSH_TX);  NRF24L01_CSN(HIGH);  }void NRF24L01_FLUSH_RX(void)  {  NRF24L01_CSN(LOW);  SPI_transfer(FLUSH_RX);  NRF24L01_CSN(HIGH);  }void NRF24L01_REUSE_TX_PL(void)  {  NRF24L01_CSN(LOW);  SPI_transfer(REUSE_TX_PL);  NRF24L01_CSN(HIGH);  }void NRF24L01_CSN(boolean csn_state)  {	digitalWrite(NRF_CSN_PIN,csn_state);  }//======================================================================================================================#if NRF_HARDWARE_SPIvoid SPI_begin()  {  SPI.begin();  SPI.setDataMode(SPI_MODE0);  SPI.setClockDivider(SPI_CLOCK_DIV16);	digitalWrite(NRF_CSN_PIN,HIGH);                                               // eerst hoog zetten, daarna output,  pinMode(NRF_CSN_PIN,OUTPUT);                                                  // anders ontstaat er een CSN pulse  }unsigned char SPI_transfer(unsigned char Byte)  {  return SPI.transfer(Byte);  }#else// Software SPI routinesvoid SPI_begin()  {  pinMode(NRF_MISO_PIN,INPUT);  pinMode(NRF_MISO_PIN,INPUT_PULLUP);  pinMode(NRF_SCK_PIN,OUTPUT);   digitalWrite(NRF_SCK_PIN,LOW);  pinMode(NRF_MOSI_PIN,OUTPUT);  digitalWrite(NRF_MOSI_PIN,HIGH);	digitalWrite(NRF_CSN_PIN,HIGH);                                               // eerst hoog zetten, daarna output,  pinMode(NRF_CSN_PIN,OUTPUT);                                                  // anders ontstaat er een CSN pulse  }unsigned char SPI_transfer(unsigned char Byte)  {  uint8_t mosibit = digitalPinToBitMask(NRF_MOSI_PIN);  uint8_t mosiport = digitalPinToPort(NRF_MOSI_PIN);  uint8_t sckbit = digitalPinToBitMask(NRF_SCK_PIN);  uint8_t sckport = digitalPinToPort(NRF_SCK_PIN);  uint8_t misobit = digitalPinToBitMask(NRF_MISO_PIN);  uint8_t misoport = digitalPinToPort(NRF_MISO_PIN);  volatile uint8_t *mosiout = portOutputRegister(mosiport);  volatile uint8_t *sckout = portOutputRegister(sckport);  volatile uint8_t *misoin = portInputRegister(misoport);  uint8_t oldSREG = SREG;    noInterrupts();  for(uint8_t i=0;i<8;i++)    {    if(Byte & 0x80)    	*mosiout |= mosibit;    else	    *mosiout &= ~mosibit;    *sckout |= sckbit;    Byte <<= 1;    if (*misoin & misobit)      Byte |= 1;    *sckout &= ~sckbit;    }  interrupts();  SREG = oldSREG;  return(Byte);                                                                                                     }#endif  //======================================================================================================================byte NRF_address[5] = {NRF_ADDRESS};boolean StatusPort_NRF24L01=false;                                                      // Status die aangeeft of de poort is in of uitgeschakeld.boolean Port_NRF24L01_Init(void)  {  uint8_t x=0,y=0;    SPI_begin();                                                                          // Initialiseer poorten voor SPI-communicatie.  x= 1<<LNA_HCURR | 3<<RF_PWR | 0<<RF_DR;                                               // LNN_HCURR=1, RF_PWR=11 (Zendvermogen max. is 0dBm), RF_DR=0 (Transmissiesnelheid 1 Mbps)  NRF24L01_W_REGISTER_1(RF_SETUP, x);                                                   // Schrijf in RF_SETUP  NRF24L01_R_REGISTER(RF_SETUP,&y,1);                                                   // Lees de weggeschreven waarde in RF_SETUP weer uit.   if(y!=x)    return false;                                                                       // bij uitlezen van hetzelfde registser leverde een andere waarde. Dus er gaat iets fout!    NRF24L01_W_REGISTER_1(EN_AA,       1<<ENAA_P0);                                       // Auto-Ack Enabled voor de pipe-0  NRF24L01_W_REGISTER_1(SETUP_RETR,  (15<<ARD) | (15<<ARC));                            // Delay 15x250uS en 15 retries  NRF24L01_W_REGISTER_1(RF_CH,       NRF_CHANNEL);                                      // Selecteer kanaal dat de Nodo's gemeenschappelijk gebruiken. 0..127  NRF24L01_W_REGISTER_1(EN_RXADDR,   1<<ERX_P0);                                        // Enable data pipe-0. SETUP_AW staat na reset op 5-byte adresgrootte  NRF24L01_W_REGISTER_1(RX_PW_P0,    sizeof(struct NodoEventStruct));                   // Stel payload-size in.   	NRF_address[0]=Settings.Unit; 	NRF24L01_W_REGISTER  (RX_ADDR_P0,  &NRF_address[0],5);                                // Stel RX adres in voor pipe-0. Pipe heeft een 5-bytes adres   NRF24L01_W_REGISTER  (TX_ADDR,     &NRF_address[0],5);                                // Stel TX adres in. Deze heeft een lengte van 5 bytes 	NRF24L01_W_REGISTER_1(STATUS, (1<<RX_DR) |  (1<<TX_DS) | (1<<MAX_RT));                // Clear RX_FIFO /TX_FIFO IRQ en clear ACK-bit,    NRF24L01_FLUSH_RX();                                                                  // Maak de RX buffer leeg  NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO) | (1<<PWR_UP) | (1<<PRIM_RX));  // CRC-Aan, 1-Byte checksum, Power-Up, Prim.RX    StatusPort_NRF24L01=true;  bitWrite(HW_Config,HW_PORT_NRF24L01,1);  return true;  }//======================================================================================================================boolean Port_NRF24L01_EventReceived(struct NodoEventStruct *Event)  {  uint8_t fifo_status;  static unsigned long LastCheckTime=0L;    if(StatusPort_NRF24L01 && (LastCheckTime<millis()) )                                  // Als de module geinitialiseerd is    {    LastCheckTime = millis() + 100UL;                                                   // Kijk slechts periodiek of er data klaar staat. Niet onnodig veel tijd van hoofdloop eisen.   	NRF24L01_R_REGISTER(FIFO_STATUS,&fifo_status,1);    if(!(fifo_status & (1<<RX_EMPTY)))      {      NRF24L01_R_RX_PAYLOAD((byte *)Event, sizeof(struct NodoEventStruct));             // Vul Nodo event struct met de inhoud van de rx FIFO buffer      return true;      }    }  return false;    }//======================================================================================================================boolean Port_NRF24L01_EventSend(struct NodoEventStruct *Event)  {  byte status=0;  boolean success=false;  static unsigned long LastSendTime=0L;      if(StatusPort_NRF24L01)                                                       // Als de module geinitialiseerd is    {    // while((LastSendTime+DELAY_BETWEEN_TRANSMISSIONS)>millis());                 // respecteer een korte verwerkingstijd tussen ontvangst van events.    // LastSendTime=millis();    for(uint8_t y=1;y<=UNIT_MAX;y++)      {      if(NodoOnline(y,0)==VALUE_SOURCE_NRF24L01 ||  (Event->Type==NODO_TYPE_EVENT && Event->Command==EVENT_BOOT))        {       	NRF_address[0]=y;        NRF24L01_FLUSH_TX();                                                                 // Maak de TX buffer leeg        NRF24L01_W_TX_PAYLOAD((uint8_t*)Event, sizeof(struct NodoEventStruct));              // Laadt data in TX_FIFO regester    	  NRF24L01_W_REGISTER_1(STATUS, (1<<RX_DR) |  (1<<TX_DS) | (1<<MAX_RT));               // Clear RX_FIFO /TX_FIFO IRQ en clear ACK-bit,          NRF24L01_W_REGISTER  (TX_ADDR   ,&NRF_address[0],5);                                 // Stel TX adres in. Deze heeft een lengte van 5 bytes         NRF24L01_W_REGISTER  (RX_ADDR_P0,&NRF_address[0],5);                                 // Stel adres voor pipe-0 op zelfde adres voor ontvangst ACK.         NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO) );                             // Eerst PowerDown, dan PowerUp omdat de CE lijn niet wordt gebruikt zetten we zo de verzending in gang.    	  NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO) | (1<<PWR_UP) | (0<<PRIM_RX)); // Power Up in Prim.TX mode            unsigned long timer=millis()+50;                                                     // wacht niet langer dan x mSec. op reactie.        while(millis()<timer)          {        	NRF24L01_R_REGISTER(STATUS, &status, 1);          if((status & ((1<<TX_DS) | (1<<MAX_RT))))            {            if(status & (1<<TX_DS))              {              NodoOnline(y,VALUE_SOURCE_NRF24L01);                                       // Als verzending gelukt, dan aan andere zijde ook een Nodo met een NRF24L01              success=true;              }            break;            }          }        }      }    // Weer terug in normale ontvangst modus  	NRF_address[0]=Settings.Unit;    NRF24L01_W_REGISTER(TX_ADDR   ,&NRF_address[0],5);                                   // Stel TX adres in. Deze heeft een lengte van 5 bytes     NRF24L01_W_REGISTER(RX_ADDR_P0,&NRF_address[0],5);                                   // Stel adres voor pipe-0 op zelde adres voor ontvangst ACK.     NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO)  | (1<<PWR_UP) | (1<<PRIM_RX));// CRC-Aan, 1-Byte checksum, Power-Up, Prim.RX  	  NRF24L01_W_REGISTER_1(STATUS, (1<<RX_DR)  | (1<<TX_DS) | (1<<MAX_RT));               // Clear RX_FIFO /TX_FIFO IRQ en clear ACK-bit,      }  return success;    }boolean Port_NRF24L01_Online(boolean Status)  {  if(bitRead(HW_Config,HW_PORT_NRF24L01))    {    StatusPort_NRF24L01=Status;    if(StatusPort_NRF24L01)      NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO) | (1<<PWR_UP) | (1<<PRIM_RX));  // CRC-Aan, 1-Byte checksum, Power-Up, Prim.RX    else      NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO));  // CRC-Aan, 1-Byte checksum, Power-Down, Prim.RX      return true;    }  else    return false;  }boolean Port_NRF24L01_OnlineStatus(void)  {  return StatusPort_NRF24L01;  }//======================================================================================================================#endif // #ifdef NODO_PORT_NRF24L01