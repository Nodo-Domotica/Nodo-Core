//======================================================================================================================// Poort NRF24L01 // // Ondersteuning voor Nordic Semiconductor nRF24L01 Single chip 2.4 Ghz Tranceiver// Voor toelichting zie Preliminary product specification Rev. 1.2 van Nordic Semiconductor.// //======================================================================================================================#if HARDWARE_NRF24L01 && (HARDWARE_SPI_HARDWARE || HARDWARE_SPI_SOFTWARE)#define NODO_NRF_RETRY                             25                           // 10 resends als de NRF een timeout afgeeft (NRF doet zelf ook 15 retries!)#define NODO_NRF_RETRY_DELAY                      250                           // wachttijd tussen de retries.#define NODO_DEBUG_NRF24L01                     false// Memory Map Mnemonics - Hex-address#define CONFIG              0x00#define EN_AA               0x01#define EN_RXADDR           0x02#define SETUP_AW            0x03#define SETUP_RETR          0x04#define RF_CH               0x05#define RF_SETUP            0x06#define STATUS              0x07#define OBSERVE_TX          0x08#define CD                  0x09#define RX_ADDR_P0          0x0A#define RX_ADDR_P1          0x0B#define RX_ADDR_P2          0x0C#define RX_ADDR_P3          0x0D#define TX_ADDR             0x10#define RX_PW_P0            0x11#define RX_PW_P1            0x12#define RX_PW_P2            0x13#define RX_PW_P3            0x14#define FIFO_STATUS         0x17//Bit Mnemonics                #define MASK_RX_DR             6#define MASK_TX_DS             5#define MASK_MAX_RT            4#define EN_CRC                 3#define CRCO                   2#define PWR_UP                 1#define PRIM_RX                0#define ENAA_P5                5#define ENAA_P4                4#define ENAA_P3                3#define ENAA_P2                2#define ENAA_P1                1#define ENAA_P0                0#define ERX_P5                 5#define ERX_P4                 4#define ERX_P3                 3#define ERX_P2                 2#define ERX_P1                 1#define ERX_P0                 0#define AW                     0#define ARD                    4#define ARC                    0#define PLL_LOCK               4#define RF_DR                  3#define RF_PWR                 1#define LNA_HCURR              0        #define RX_DR                  6#define TX_DS                  5#define MAX_RT                 4#define RX_P_NO                1#define TX_FULL                0#define PLOS_CNT               4#define ARC_CNT                0#define CD                     0#define TX_REUSE               6#define FIFO_FULL              5#define TX_EMPTY               4#define RX_FULL                1#define RX_EMPTY               0// NRF24L01 - SPI-Instruction set#define R_REGISTER          0x00#define W_REGISTER          0x20#define R_RX_PAYLOAD        0x61#define W_TX_PAYLOAD        0xA0#define FLUSH_TX            0xE1#define FLUSH_RX            0xE2#define REUSE_TX_PL         0xE3#define NOP                 0xFFvoid NRF24L01_R_REGISTER(uint8_t reg, uint8_t *data, uint8_t len)  {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(R_REGISTER | (0x1F & reg));	for(uint8_t i = 0;i < len;i++)		data[i] = SPI_transfer(data[i]);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  } void NRF24L01_W_REGISTER_1(uint8_t reg, uint8_t value)  {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(W_REGISTER | (0x1F & reg));  SPI_transfer(value);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  }void NRF24L01_W_REGISTER(uint8_t reg, uint8_t *value, uint8_t len)   {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(W_REGISTER | (0x1F & reg));	for(uint8_t i = 0;i < len;i++)		SPI_transfer(value[i]);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  }void NRF24L01_R_RX_PAYLOAD(uint8_t *data, uint8_t len)   {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(R_RX_PAYLOAD);	for(uint8_t i = 0;i < len;i++)		data[i] = SPI_transfer(data[i]);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  NRF24L01_W_REGISTER_1(STATUS,(1<<RX_DR));  }void NRF24L01_W_TX_PAYLOAD(uint8_t *data, uint8_t len)  {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(W_TX_PAYLOAD);	for(uint8_t i = 0;i < len;i++)		SPI_transfer(data[i]);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  }void NRF24L01_FLUSH_TX(void)  {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(FLUSH_TX);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  }void NRF24L01_FLUSH_RX(void)  {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(FLUSH_RX);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  }void NRF24L01_REUSE_TX_PL(void)  {  SPI_CSN(PIN_SPI_CSN_0,LOW);  SPI_transfer(REUSE_TX_PL);  SPI_CSN(PIN_SPI_CSN_0,HIGH);  }//======================================================================================================================byte NRF_address[5] = {NRF_ADDRESS};boolean Port_NRF24L01_Init(void)  {  uint8_t x=0,y=0;  x= 1<<LNA_HCURR | 3<<RF_PWR | 0<<RF_DR;                                               // LNN_HCURR=1, RF_PWR=11 (Zendvermogen max. is 0dBm), RF_DR=0 (Transmissiesnelheid 1 Mbps)  NRF24L01_W_REGISTER_1(RF_SETUP, x);                                                   // Schrijf in RF_SETUP  NRF24L01_R_REGISTER(RF_SETUP,&y,1);                                                   // Lees de weggeschreven waarde in RF_SETUP weer uit.   if(y!=x)    return false;                                                                       // bij uitlezen van hetzelfde registser leverde een andere waarde. Dus er gaat iets fout!  NRF24L01_W_REGISTER_1(EN_AA,       1<<ENAA_P0);                                       // Auto-Ack Enabled voor de pipe-0  NRF24L01_W_REGISTER_1(SETUP_RETR,  (15<<ARD) | (15<<ARC));                            // Delay 15x250uS en 15 retries  NRF24L01_W_REGISTER_1(RF_CH,       NRF_CHANNEL);                                      // Selecteer kanaal dat de Nodo's gemeenschappelijk gebruiken. 0..127  NRF24L01_W_REGISTER_1(EN_RXADDR,   1<<ERX_P0);                                        // Enable data pipe-0.  NRF24L01_W_REGISTER_1(RX_PW_P0,    sizeof(struct NodoEventStruct));                   // Stel payload-size in.   	NRF_address[0]=Settings.Unit; 	NRF24L01_W_REGISTER  (RX_ADDR_P0,  &NRF_address[0],5);                                // Stel RX adres in voor pipe-0. Pipe heeft een 5-bytes adres   NRF24L01_W_REGISTER  (TX_ADDR,     &NRF_address[0],5);                                // Stel TX adres in. Deze heeft een lengte van 5 bytes 	NRF24L01_W_REGISTER_1(STATUS, (1<<RX_DR) |  (1<<TX_DS) | (1<<MAX_RT));                // Clear RX_FIFO /TX_FIFO IRQ en clear ACK-bit,    NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO) | (1<<PWR_UP) | (1<<PRIM_RX));  // CRC-Aan, 1-Byte checksum, Power-Up, Prim.RX    NRF24L01_FLUSH_RX();                                                                  // Maak de RX buffer leeg  NRF24L01_FLUSH_TX();                                                                  // Maak de RX buffer leeg  return true;  }//======================================================================================================================boolean Port_NRF24L01_EventReceived(struct NodoEventStruct *Event)  {  uint8_t fifo_status;  static unsigned long LastCheckTime=0L;    if(HW_Status(HW_NRF24L01) && (LastCheckTime<millis()) )                                    // Als de module geinitialiseerd is    {    LastCheckTime = millis() + 50UL;                                                        // Kijk slechts periodiek of er data klaar staat. Niet onnodig veel tijd van hoofdloop eisen.   	NRF24L01_R_REGISTER(FIFO_STATUS,&fifo_status,1);    if(!(fifo_status & (1<<RX_EMPTY)))      {      NRF24L01_R_RX_PAYLOAD((byte *)Event, sizeof(struct NodoEventStruct));                  // Vul Nodo event struct met de inhoud van de rx FIFO buffer      #if NODO_DEBUG_NRF24L01      PrintNodoEvent("DEBUG: NRF24L01_EventReceived(); Event=",Event);//???      #endif      return true;      }    }  return false;    }//======================================================================================================================byte Port_NRF24L01_EventSend(struct NodoEventStruct *Event)  {  byte status,y,first,last,attempt;   uint8_t fifo_status;  byte error=0;  if(HW_Status(HW_NRF24L01))                                                                    // Als de module geinitialiseerd is    {    #if NODO_DEBUG_NRF24L01    PrintNodoEvent("DEBUG: NRF24L01_EventSend(); Event=",Event);//???    #endif    if(Event->DestinationUnit!=0)      {      first=Event->DestinationUnit;      last=Event->DestinationUnit;      }    else      {      first=1;      last=UNIT_MAX;      }    for(y=first;y<=last;y++)      {      if((NodoOnline(y,0,false)==VALUE_SOURCE_NRF24L01 || Event->Flags&TRANSMISSION_BROADCAST) && y!=Settings.Unit)        {        #if NODO_DEBUG_NRF24L01        Serial.print("DEBUG: Send to unit ");Serial.println(y);//???        #endif                NRF_address[0]=y;        NRF24L01_W_REGISTER  (TX_ADDR   ,&NRF_address[0],5);                                 // Stel TX adres in. Deze heeft een lengte van 5 bytes         NRF24L01_W_REGISTER  (RX_ADDR_P0,&NRF_address[0],5);                                 // Stel adres voor pipe-0 op zelfde adres voor ontvangst ACK.    	  NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO));                              // Power Down in Prim.TX mode.        delayMicroseconds(1500);                                                             // Startup tijd 1.5 mSec    	  NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO) | (1<<PWR_UP));                // Prim.TX mode. FIFO is leeg, dus Standby-II mode. Zodra FIFO gevuld start TX        attempt=1;        while(!error && attempt)          {      	  NRF24L01_W_REGISTER_1(STATUS, (1<<RX_DR) |  (1<<TX_DS) | (1<<MAX_RT));               // Clear RX_FIFO-IRQ /TX_FIFO-IRQ en clear ACK-bit,            NRF24L01_W_TX_PAYLOAD((uint8_t*)Event, sizeof(struct NodoEventStruct));              // Laadt data in TX_FIFO regester, NRF gaat in TX mode en zendt pakket en valt daarna in Standby-II          #if NODO_DEBUG_NRF24L01          Serial.print("Attempt ");Serial.print(attempt);//???          #endif          unsigned long timer=millis()+250;                                                    // wacht niet langer dan x mSec. op reactie.          while(millis()<timer)                                                                            {          	NRF24L01_R_REGISTER(STATUS, &status, 1);              if(status & (1<<TX_DS))                                                            // Zodra verzending gelukt zal TX_DS vlag worden gezet              {              attempt=0;              NodoOnline(y,VALUE_SOURCE_NRF24L01,true);              #if NODO_DEBUG_NRF24L01              Serial.println(", Success");//???              #endif              break;              }            if(status & (1<<MAX_RT))                                                           // Als verzending is mislukt;              {              #if NODO_DEBUG_NRF24L01              Serial.println(", No response.");//???              #endif              if((Event->Flags&TRANSMISSION_BROADCAST) == 0)                {                delay(NODO_NRF_RETRY_DELAY + 10* Settings.Unit);                if(attempt++ >= NODO_NRF_RETRY)                  {                  #if NODO_DEBUG_NRF24L01                  Serial.println(", Failed.");//???                  #endif                  NodoOnline(y,0,true);                                         // verwijder uit de lijst.                  attempt=0;                  error=y;                                  }                }              else                attempt=0;              break;              }            }// while millis()<timer          }//while !error        }// if NodoOnline      }// for    // Weer terug in normale ontvangst modus    NRF24L01_FLUSH_TX();  	NRF_address[0]=Settings.Unit;    NRF24L01_W_REGISTER(TX_ADDR   ,&NRF_address[0],5);                                       // Stel TX adres in. Deze heeft een lengte van 5 bytes     NRF24L01_W_REGISTER(RX_ADDR_P0,&NRF_address[0],5);                                       // Stel adres voor pipe-0 op zelde adres voor ontvangst ACK.  	  NRF24L01_W_REGISTER_1(STATUS, (1<<RX_DR)  | (1<<TX_DS) | (1<<MAX_RT));                   // Clear RX_FIFO /TX_FIFO IRQ en clear ACK-bit,  	  NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO));                                  // Power Down in Prim.TX mode.    delayMicroseconds(1500);                                                                 // Startup tijd 1.5 mSec    NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO)  | (1<<PWR_UP) | (1<<PRIM_RX));    // CRC-Aan, 1-Byte checksum, Power-Up, Prim.RX      }  return error;                                                                               }void Port_NRF24L01_POWER(boolean Status)  {  if(HW_Status(HW_NRF24L01))    {    if(Status)      NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO) | (1<<PWR_UP) | (1<<PRIM_RX));   // CRC-Aan, 1-Byte checksum, Power-Up, Prim.RX    else      NRF24L01_W_REGISTER_1(CONFIG, (1<<EN_CRC) | (0<<CRCO));                                // CRC-Aan, 1-Byte checksum, Power-Down, Prim.RX      }  }//======================================================================================================================#endif // NODO_PORT_NRF24L01