/******************************************************************************\boolean Port_xxx_Init(void);boolean Port_xxx_EventSend(struct NodoEventStruct *Event);boolean Port_xxx_EventReceived(struct NodoEventStruct *Event);boolean Port_xxx_CommandSend(char* Command);boolean Port_xxx_CommandReceived(char* Command);boolean Port_xxx_Online(boolean Status);boolean Port_xxx_OnlineStatus(void);        \******************************************************************************/#if NODO_PORT_I2C#define I2C_START_ADDRESS                    1                                  // Alle Nodo's op de I2C bus hebben een uniek adres dat start vanaf dit nummer. Er zijn max. 32 Nodo's. Let op overlap met andere devices. RTC zit op adres 104.int  I2C_Received=0;                                                            // Bevat aantal binnengomen bytes op I2C;struct TransmissionStruct I2C_ReceiveBlock, I2C_SendBlock;boolean StatusPort_I2C=false;                                                   // Status die aangeeft of de poort is in of uitgeschakeld.//======================================================================================================================boolean Port_I2C_Init(void)  {  WireNodo.begin(Settings.Unit + I2C_START_ADDRESS - 1);                        // Start luisteren naar de I2C poort.  WireNodo.onReceive(OnReceiveI2C);                                             // verwijs naar de I2C ontvangstroutine  WireNodo.onRequest(OnRequestI2C);  bitWrite(HW_Config,HW_PORT_I2C,1);  StatusPort_I2C=true;  return true;  }//======================================================================================================================boolean Port_I2C_EventReceived(struct NodoEventStruct *Event)  {  static unsigned long LastCheckTime=0L;  uint8_t x;      if(bitRead(HW_Config,HW_PORT_I2C) && (LastCheckTime<millis()) )               // Als de module geinitialiseerd is    {    LastCheckTime = millis() + 100UL;                                           // Kijk slechts periodiek of er data klaar staat. Niet onnodig veel tijd van hoofdloop eisen.    if(I2C_Received==sizeof(struct TransmissionStruct))                         // Er is I2C data binnengekomen maar weten nog niet of het een geldig NodoEventStruct betreft.      {                                                                         // Het is een NodoEventStruct      I2C_Received=0;      if(TransmissionChecksum(&I2C_ReceiveBlock))        {        Event->SourceUnit      = I2C_ReceiveBlock.SourceUnit;        Event->DestinationUnit = I2C_ReceiveBlock.DestinationUnit;        Event->Flags           = I2C_ReceiveBlock.Flags;        Event->Type            = I2C_ReceiveBlock.Type;        Event->Command         = I2C_ReceiveBlock.Command;        Event->Par1            = I2C_ReceiveBlock.Par1;        Event->Par2            = I2C_ReceiveBlock.Par2;        Event->Payload         = I2C_ReceiveBlock.Payload;        return true;        }      }    }  return false;    }//======================================================================================================================boolean Port_I2C_EventSend(struct NodoEventStruct *Event)  {  byte x;  boolean success=false;    for(int y=1;y<=UNIT_MAX;y++)    {                if(NodoOnline(y,0)==VALUE_SOURCE_I2C  || Event->Flags&TRANSMISSION_BROADCAST)      {      I2C_SendBlock.SourceUnit      = Event->SourceUnit;      I2C_SendBlock.DestinationUnit = Event->DestinationUnit;      I2C_SendBlock.Flags           = Event->Flags;      I2C_SendBlock.Type            = Event->Type;      I2C_SendBlock.Command         = Event->Command;      I2C_SendBlock.Par1            = Event->Par1;      I2C_SendBlock.Par2            = Event->Par2;      I2C_SendBlock.Payload         = Event->Payload;      TransmissionChecksum(&I2C_SendBlock);      WireNodo.beginTransmission(I2C_START_ADDRESS+y-1);      for(x=0;x<sizeof(struct TransmissionStruct);x++)        WireNodo.write(*(((byte*)&I2C_SendBlock)+x));      WireNodo.endTransmission(true);                                           // verzend de data en sluit af.      x=0;      WireNodo.requestFrom(I2C_START_ADDRESS+y-1, 1);                           // We verzoeken de slave om een reactie.      unsigned long WaitForResponseTimer=millis()+100;                          // We wachten kort op reactie van de slave.      while(WaitForResponseTimer>millis() && x==0)        while(WireNodo.available())          x=WireNodo.read();                                                    // Lees teken dat de slave op verzoek verzendt naar deze master      if(x==y)success=true;      NodoOnline(y,success?VALUE_SOURCE_I2C:0);                                    // Als we deze ontvangen hebben, dan weten we dat de Nodo op de bus zit.      }    }  // WireNodo.endTransmission(true);                                            // Geef de bus vrij  return success;    }void OnReceiveI2C(int n)                                                        // Deze routine wordt vanuit de Wire library aangeroepen zodra er data op de I2C bus verschijnt die voor deze nodo bestemd is.  {  I2C_Received=0;    while(WireNodo.available())    if(I2C_Received<sizeof(struct TransmissionStruct))      *(((byte*)&I2C_ReceiveBlock)+I2C_Received++)=WireNodo.read();  }void OnRequestI2C()  {  WireNodo.write(Settings.Unit);                                                // Dit is voor een snelle test vanuit een master of een slave online is. Een request    }                                                                             // wordt door deze slave Nodo beantwoord met het unitnummer van deze Nodo.boolean Port_I2C_Online(boolean Status)  {  if(bitRead(HW_Config,HW_PORT_I2C))    {    StatusPort_I2C=Status;    if(StatusPort_I2C)      return true;    }  else    return false;  }boolean Port_I2C_OnlineStatus(void)  {  return StatusPort_I2C;  }#endif // #ifdef NODO_PORT_I2C  