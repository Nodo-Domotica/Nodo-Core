#if HARDWARE_I2C#define I2C_START_ADDRESS                    1                                  // Alle Nodo's op de I2C bus hebben een uniek adres dat start vanaf dit nummer. Er zijn max. 32 Nodo's. Let op overlap met andere devices. RTC zit op adres 104.int  I2C_Received=0;                                                            // Bevat aantal binnengomen bytes op I2C;struct TransmissionStruct I2C_ReceiveBlock, I2C_SendBlock;#define NODO_I2C_RESPONSE_NONE               1                                  // geen ontvangst status#define NODO_I2C_RESPONSE_OK                 2                                  // Event is ontvangen en opgepakt voor verwerking#define NODO_I2C_RESPONSE_ERROR              3                                  // Data is ontvangen, maar geen geldig event.byte I2C_Response=NODO_I2C_RESPONSE_NONE;//======================================================================================================================boolean Port_I2C_Init(void)  {  Wire.begin(Settings.Unit + I2C_START_ADDRESS - 1);                        // Start luisteren naar de I2C poort.  Wire.onReceive(OnReceiveI2C);                                             // verwijs naar de I2C ontvangstroutine  Wire.onRequest(OnRequestI2C);  return true;  }//======================================================================================================================boolean Port_I2C_EventReceived(struct NodoEventStruct *Event)  {  static unsigned long LastCheckTime=0L;  byte x;      if(HW_Status(HW_I2C) && (LastCheckTime<millis()) )                            // Als de module geinitialiseerd is    {    LastCheckTime = millis() + 50UL;                                            // Kijk slechts periodiek of er data klaar staat. Niet onnodig veel tijd van hoofdloop eisen.    if(I2C_Received==sizeof(struct TransmissionStruct))                         // Er is I2C data binnengekomen maar weten nog niet of het een geldig NodoEventStruct betreft.      {                                                                         // Het is een NodoEventStruct      I2C_Received=0;      if(TransmissionChecksum(&I2C_ReceiveBlock))        {        Event->SourceUnit      = I2C_ReceiveBlock.SourceUnit;        Event->DestinationUnit = I2C_ReceiveBlock.DestinationUnit;        Event->Flags           = I2C_ReceiveBlock.Flags;        Event->Type            = I2C_ReceiveBlock.Type;        Event->Command         = I2C_ReceiveBlock.Command;        Event->Par1            = I2C_ReceiveBlock.Par1;        Event->Par2            = I2C_ReceiveBlock.Par2;        Event->Payload         = I2C_ReceiveBlock.Payload;        I2C_Response           = NODO_I2C_RESPONSE_OK;                          // event in goede orde ontvangen        NodoOnline(Event->DestinationUnit,VALUE_SOURCE_I2C,true);        return true;        }      else        I2C_Response           = NODO_I2C_RESPONSE_ERROR;                       // data ontvange, maar geen geldig event      }    }  return false;    }//======================================================================================================================boolean Port_I2C_EventSend(struct NodoEventStruct *Event)  {  byte first,last,x,y;  boolean success=false;  if(Event->DestinationUnit!=0)    {    first=Event->DestinationUnit;    last=Event->DestinationUnit;    }  else    {    first=1;    last=UNIT_MAX;    }    for(y=first;y<=last;y++)    {                if((NodoOnline(y,0,false)==VALUE_SOURCE_I2C  || Event->Flags&TRANSMISSION_BROADCAST) && y!=Settings.Unit)      {      I2C_SendBlock.SourceUnit      = Event->SourceUnit;      I2C_SendBlock.DestinationUnit = Event->DestinationUnit;      I2C_SendBlock.Flags           = Event->Flags;      I2C_SendBlock.Type            = Event->Type;      I2C_SendBlock.Command         = Event->Command;      I2C_SendBlock.Par1            = Event->Par1;      I2C_SendBlock.Par2            = Event->Par2;      I2C_SendBlock.Payload         = Event->Payload;      TransmissionChecksum(&I2C_SendBlock);      Wire.beginTransmission(I2C_START_ADDRESS+y-1);      for(x=0;x<sizeof(struct TransmissionStruct);x++)        Wire.write(*(((byte*)&I2C_SendBlock)+x));      Wire.endTransmission(true);                                               // verzend de data en sluit af, maar geef bus niet vrij.            x=0;      unsigned long WaitForResponseTimer=millis()+2000;                          // We wachten kort op reactie van de slave.      do        {        Wire.requestFrom(I2C_START_ADDRESS+y-1, 1);                             // We verzoeken de slave om een reactie.        delay(10);        while(Wire.available())x=Wire.read();                                   // Lees teken dat de slave op verzoek verzendt naar deze master        }while(WaitForResponseTimer>millis() && x==NODO_I2C_RESPONSE_NONE);     // OK is de standaard response van een Nodo in 'rust'      success=(x==NODO_I2C_RESPONSE_OK);      NodoOnline(y,VALUE_SOURCE_I2C,(x==NODO_I2C_RESPONSE_OK));                 // Als we deze ontvangen hebben, dan weten we dat de Nodo op de bus zit.      }    }  return success;    }void OnReceiveI2C(int n)                                                        // Deze routine wordt vanuit de Wire library aangeroepen zodra er data op de I2C bus verschijnt die voor deze nodo bestemd is.  {  I2C_Received=0;    while(Wire.available())    if(I2C_Received<sizeof(struct TransmissionStruct))      *(((byte*)&I2C_ReceiveBlock)+I2C_Received++)=Wire.read();  }void OnRequestI2C()  {  Wire.write(I2C_Response);                                                     // Dit is voor een snelle test vanuit een master naar de status van deze slave.   I2C_Response=NODO_I2C_RESPONSE_NONE;                                            // 'rust'-stand van de Nodo.  }    #endif // HARDWARE_I2C  