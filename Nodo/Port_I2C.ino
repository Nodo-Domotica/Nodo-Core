#if HARDWARE_I2C#define I2C_START_ADDRESS                    1                                  // Alle Nodo's op de I2C bus hebben een uniek adres dat start vanaf dit nummer. Er zijn max. 32 Nodo's. Let op overlap met andere devices. RTC zit op adres 104.int  I2C_Received=0;                                                            // Bevat aantal binnengomen bytes op I2C;struct TransmissionStruct I2C_ReceiveBlock, I2C_SendBlock;//======================================================================================================================boolean Port_I2C_Init(void)  {  Wire.begin(Settings.Unit + I2C_START_ADDRESS - 1);                        // Start luisteren naar de I2C poort.  Wire.onReceive(OnReceiveI2C);                                             // verwijs naar de I2C ontvangstroutine  Wire.onRequest(OnRequestI2C);  return true;  }//======================================================================================================================boolean Port_I2C_EventReceived(struct NodoEventStruct *Event)  {  static unsigned long LastCheckTime=0L;  byte x;      if(HW_Status(HW_I2C) && (LastCheckTime<millis()) )                            // Als de module geinitialiseerd is    {    LastCheckTime = millis() + 100UL;                                           // Kijk slechts periodiek of er data klaar staat. Niet onnodig veel tijd van hoofdloop eisen.    if(I2C_Received==sizeof(struct TransmissionStruct))                         // Er is I2C data binnengekomen maar weten nog niet of het een geldig NodoEventStruct betreft.      {                                                                         // Het is een NodoEventStruct      I2C_Received=0;      if(TransmissionChecksum(&I2C_ReceiveBlock))        {        Event->SourceUnit      = I2C_ReceiveBlock.SourceUnit;        Event->DestinationUnit = I2C_ReceiveBlock.DestinationUnit;        Event->Flags           = I2C_ReceiveBlock.Flags;        Event->Type            = I2C_ReceiveBlock.Type;        Event->Command         = I2C_ReceiveBlock.Command;        Event->Par1            = I2C_ReceiveBlock.Par1;        Event->Par2            = I2C_ReceiveBlock.Par2;        Event->Payload         = I2C_ReceiveBlock.Payload;        NodoOnline(Event->DestinationUnit,VALUE_SOURCE_I2C,true);        return true;        }      }    }  return false;    }//======================================================================================================================boolean Port_I2C_EventSend(struct NodoEventStruct *Event)  {  byte first,last,x,y;  boolean success=false;    if(Event->DestinationUnit!=0)    {    first=Event->DestinationUnit;    last=Event->DestinationUnit;    }  else    {    first=1;    last=UNIT_MAX;    }    for(y=first;y<=last;y++)    {                if((NodoOnline(y,0,false)==VALUE_SOURCE_I2C  || Event->Flags&TRANSMISSION_BROADCAST) && y!=Settings.Unit)      {      I2C_SendBlock.SourceUnit      = Event->SourceUnit;      I2C_SendBlock.DestinationUnit = Event->DestinationUnit;      I2C_SendBlock.Flags           = Event->Flags;      I2C_SendBlock.Type            = Event->Type;      I2C_SendBlock.Command         = Event->Command;      I2C_SendBlock.Par1            = Event->Par1;      I2C_SendBlock.Par2            = Event->Par2;      I2C_SendBlock.Payload         = Event->Payload;      TransmissionChecksum(&I2C_SendBlock);      Wire.beginTransmission(I2C_START_ADDRESS+y-1);      for(x=0;x<sizeof(struct TransmissionStruct);x++)        Wire.write(*(((byte*)&I2C_SendBlock)+x));      Wire.endTransmission(true);                                           // verzend de data en sluit af.      x=0;      Wire.requestFrom(I2C_START_ADDRESS+y-1, 1);                           // We verzoeken de slave om een reactie.      unsigned long WaitForResponseTimer=millis()+100;                          // We wachten kort op reactie van de slave.      while(WaitForResponseTimer>millis() && x==0)        while(Wire.available())          x=Wire.read();                                                    // Lees teken dat de slave op verzoek verzendt naar deze master      if(x==y)        {        success=true;        NodoOnline(y,VALUE_SOURCE_I2C,true);                                    // Als we deze ontvangen hebben, dan weten we dat de Nodo op de bus zit.        }      }    }  // Wire.endTransmission(true);                                            // Geef de bus vrij???  return success;    }void OnReceiveI2C(int n)                                                        // Deze routine wordt vanuit de Wire library aangeroepen zodra er data op de I2C bus verschijnt die voor deze nodo bestemd is.  {  I2C_Received=0;    while(Wire.available())    if(I2C_Received<sizeof(struct TransmissionStruct))      *(((byte*)&I2C_ReceiveBlock)+I2C_Received++)=Wire.read();  }void OnRequestI2C()  {  Wire.write(Settings.Unit);                                                // Dit is voor een snelle test vanuit een master of een slave online is. Een request    }                                                                             // wordt door deze slave Nodo beantwoord met het unitnummer van deze Nodo.#endif // HARDWARE_I2C  