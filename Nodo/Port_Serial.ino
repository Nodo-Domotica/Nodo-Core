//======================================================================================================================// Additionele seriele poort. // // // Afhankelijk van de hardware instelling, wordt gebruik gemaakt van Hardware- of SoftwareSerial.// Dit is eigenlijk niet meer dan een 'wrapper' die de hardware configuratie onafhankelijk maakt// van de Nodo-core en plugins. Gebruik deze funkties voor Seriele communicatie in plaats van de directe // library calls. Let op dat de SoftSerial gebruik maakt van change-IRQ's en daarmee kan leiden tot// niet correct funktioneren van plugins die hier eveneens gebruik van maken. //// De volgende funkties zijn beschikbaar voor gebruik van seriele communicatie:// // Serial_begin(byte speed, byte config)// void Serial_print(char* string);// void Serial_println(char* string);// size_t Serial_write(uint8_t b);// size_t Serial_writeBuf(uint8_t* buf, byte len);// int Serial_available();// int Serial_read();// int Serial_peek();// void Serial_flush();// //======================================================================================================================//======================================================================================================================#if HARDWARE_SERIAL_2_SW#include <SoftwareSerial.h>SoftwareSerial mySerial(PIN_SERIAL_2_RX,PIN_SERIAL_2_TX); // RX, TXvoid Serial_begin(int speed, byte config)                                      // config wordt niet ondersteund en mag iedere waarde hebben.  {  mySerial.begin(speed);  }void Serial_println(char* string)  {  mySerial.println(string);  }void Serial_print(char* string)  {  mySerial.print(string);  }size_t Serial_write(uint8_t b)  {  mySerial.write(b);  }size_t Serial_writeBuf(uint8_t* buf, byte len)  {  }int Serial_available(void)  {  return mySerial.available();  }int Serial_read(void)  {  return mySerial.read();  }int Serial_peek(void)  {  return mySerial.peek();  }void Serial_flush(void)  {  mySerial.flush();  }#endif // HARDWARE_SERIAL_2_SW//======================================================================================================================#if HARDWARE_SERIAL_2_HWvoid Serial_begin(byte speed, byte config)  {  Serial3.begin(speed, config);  }void Serial_println(char* string)  {  Serial3.println(string);  }void Serial_print(char* string)  {  Serial3.print(string);  }size_t Serial_write(uint8_t b)  {  return Serial3.write(b);  }size_t Serial_writeBuf(uint8_t* buf, byte len)  {  return Serial3.write(buf,len);  }int Serial_available(void)  {  return Serial3.available();  }int Serial_read(void)  {  return Serial3.read();  }int Serial_peek(void)  {  return Serial3.peek();  }void Serial_flush(void)  {  Serial3.flush();    }  #endif // HARDWARE_SERIAL_2_HW//======================================================================================================================